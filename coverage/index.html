
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>application: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tcpchat-server-go/application/chatservice.go (0.0%)</option>
				
				<option value="file1">tcpchat-server-go/application/errors.go (0.0%)</option>
				
				<option value="file2">tcpchat-server-go/application/handlers/commandhandler.go (0.0%)</option>
				
				<option value="file3">tcpchat-server-go/application/handlers/errorhandler.go (66.7%)</option>
				
				<option value="file4">tcpchat-server-go/application/handlers/messagebroker.go (0.0%)</option>
				
				<option value="file5">tcpchat-server-go/application/handlers/newsessionhandler.go (0.0%)</option>
				
				<option value="file6">tcpchat-server-go/application/handlers/textmessagehandler.go (0.0%)</option>
				
				<option value="file7">tcpchat-server-go/application/messageconverter.go (0.0%)</option>
				
				<option value="file8">tcpchat-server-go/domain/command.go (0.0%)</option>
				
				<option value="file9">tcpchat-server-go/domain/session.go (0.0%)</option>
				
				<option value="file10">tcpchat-server-go/domain/user.go (0.0%)</option>
				
				<option value="file11">tcpchat-server-go/domain/usersession.go (0.0%)</option>
				
				<option value="file12">tcpchat-server-go/main.go (0.0%)</option>
				
				<option value="file13">tcpchat-server-go/plugin/connection.go (0.0%)</option>
				
				<option value="file14">tcpchat-server-go/plugin/readwrite.go (0.0%)</option>
				
				<option value="file15">tcpchat-server-go/plugin/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package application

import (
        "fmt"

        "tcpchat-server-go/domain"
)

type ChatService struct {
        sessionRepository     domain.SessionRepository
        userRepository        domain.UserRepository
        userSessionRepository domain.UserSessionRepository
}

func NewChatService(sessionRepository domain.SessionRepository, userRepository domain.UserRepository, userSessionRepository domain.UserSessionRepository) *ChatService <span class="cov0" title="0">{
        return &amp;ChatService{sessionRepository: sessionRepository, userRepository: userRepository, userSessionRepository: userSessionRepository}
}</span>

func (c ChatService) SendMessageToSessionFromServer(sessionID string, message string) <span class="cov0" title="0">{
        c.sendMessageToSession(sessionID, fmt.Sprintf("[plugin] %s", message))
}</span>

func (c ChatService) sendMessageToSession(sessionID string, message string) <span class="cov0" title="0">{
        session, sessionExists := c.sessionRepository.FindByID(sessionID)
        if !sessionExists </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">session.MessagesToSession &lt;- fmt.Sprintf("%s\n", message)</span>
}

func (c ChatService) RegisterNewSession(newSession domain.Session) <span class="cov0" title="0">{
        c.sessionRepository.Add(newSession)
}</span>

func (c ChatService) SendTextMessageToEveryone(sessionID, message string) error <span class="cov0" title="0">{
        _, sessionExists := c.sessionRepository.FindByID(sessionID)
        if !sessionExists </span><span class="cov0" title="0">{
                return fmt.Errorf("revieced a text Message from an unknown session id: %s", sessionID)
        }</span>
        <span class="cov0" title="0">userSession, userSessionExists := c.userSessionRepository.FindBySessionID(sessionID)
        if !userSessionExists </span><span class="cov0" title="0">{
                return NewErrSessionNotLoggedIn(sessionID)
        }</span>
        <span class="cov0" title="0">userID := userSession.UserID
        user, userExists := c.userRepository.FindByID(userID)
        if !userExists </span><span class="cov0" title="0">{
                return fmt.Errorf("user was not found, userID: %s", userID)
        }</span>
        <span class="cov0" title="0">otherSessions := c.sessionRepository.FindAllExceptBySessionID(sessionID)
        for _, otherSession := range otherSessions </span><span class="cov0" title="0">{
                c.sendMessageToSession(otherSession.ID, fmt.Sprintf("[%s] %s", user.Name, message))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c ChatService) ChangeUserName(sessionID string, newUserName string) error <span class="cov0" title="0">{
        userSession, userSessionExists := c.userSessionRepository.FindBySessionID(sessionID)
        if !userSessionExists </span><span class="cov0" title="0">{
                return NewErrSessionNotLoggedIn(sessionID)
        }</span>
        <span class="cov0" title="0">user, userExists := c.userRepository.FindByID(userSession.UserID)
        if !userExists </span><span class="cov0" title="0">{
                return fmt.Errorf("user was not found, userID: %s", userSession.UserID)
        }</span>
        <span class="cov0" title="0">user.Name = newUserName
        return nil</span>
}

func (c ChatService) SendPrivateMessage(sessionID, messagePartnerUserName, message string) error <span class="cov0" title="0">{
        userSession, userSessionExists := c.userSessionRepository.FindBySessionID(sessionID)
        if !userSessionExists </span><span class="cov0" title="0">{
                return NewErrSessionNotLoggedIn(sessionID)
        }</span>
        <span class="cov0" title="0">user, userExists := c.userRepository.FindByID(userSession.UserID)
        if !userExists </span><span class="cov0" title="0">{
                return fmt.Errorf("user was not found, userID: %s", userSession.UserID)
        }</span>
        <span class="cov0" title="0">messagePartnerUser, messagePartnerUserExists := c.userRepository.FindByName(messagePartnerUserName)
        if !messagePartnerUserExists </span><span class="cov0" title="0">{
                return NewErrMessagePartnerDoesNotExist(sessionID, messagePartnerUserName)
        }</span>
        <span class="cov0" title="0">messagePartnerUserSessions := c.userSessionRepository.FindByUserID(messagePartnerUser.ID)
        if len(messagePartnerUserSessions) == 0 </span><span class="cov0" title="0">{
                return NewErrMessagePartnerNotLoggedIn(sessionID, messagePartnerUserName)
        }</span>
        <span class="cov0" title="0">for _, partnerUserSession := range messagePartnerUserSessions </span><span class="cov0" title="0">{
                c.sendMessageToSession(partnerUserSession.SessionID, fmt.Sprintf("[p %s] %s", user.Name, message))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c ChatService) CreateAccount(sessionID, userName, password string) error <span class="cov0" title="0">{
        user, err := domain.NewUser(userName, password)
        if err != nil </span><span class="cov0" title="0">{
                return NewErrCouldNotCreateUser(sessionID)
        }</span>
        <span class="cov0" title="0">addedUser := c.userRepository.Add(user)
        if !addedUser </span><span class="cov0" title="0">{
                return NewErrUserNameAlreadyExists(sessionID, userName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c ChatService) Login(sessionID, userName, password string) error <span class="cov0" title="0">{
        user, userExists := c.userRepository.FindByName(userName)
        if !userExists </span><span class="cov0" title="0">{
                return NewErrUserDoesNotExist(sessionID, userName)
        }</span>
        <span class="cov0" title="0">passwordIsValid := user.PasswordIsValid(password)
        if !passwordIsValid </span><span class="cov0" title="0">{
                return NewErrPasswordIsInvalid(sessionID)
        }</span>
        <span class="cov0" title="0">userSession := domain.NewUserSession(user.ID, sessionID)
        c.userSessionRepository.Add(userSession)
        return nil</span>
}

func (c ChatService) ChangePassword(sessionID, oldPassword, newPassword string) error <span class="cov0" title="0">{
        userSession, userSessionExists := c.userSessionRepository.FindBySessionID(sessionID)
        if !userSessionExists </span><span class="cov0" title="0">{
                return NewErrSessionNotLoggedIn(sessionID)
        }</span>
        <span class="cov0" title="0">user, userExists := c.userRepository.FindByID(userSession.UserID)
        if !userExists </span><span class="cov0" title="0">{
                return fmt.Errorf("user was not found, userID: %s", userSession.UserID)
        }</span>
        <span class="cov0" title="0">if !user.PasswordIsValid(oldPassword) </span><span class="cov0" title="0">{
                return NewErrPasswordIsInvalid(sessionID)
        }</span>
        <span class="cov0" title="0">err := user.SetPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return NewErrPasswordIsInvalid(sessionID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c ChatService) GetUserNameForSessionID(sessionID string) string <span class="cov0" title="0">{
        userSession, userSessionExists := c.userSessionRepository.FindBySessionID(sessionID)
        if !userSessionExists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">user, userExists := c.userRepository.FindByID(userSession.UserID)
        if !userExists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return user.Name</span>
}

func (c ChatService) GetAllLoggedInUserNames() []string <span class="cov0" title="0">{
        userNames := make([]string, 0)
        for _, user := range c.userRepository.GetAll() </span><span class="cov0" title="0">{
                userSessions := c.userSessionRepository.DeleteByUserID(user.ID)
                if len(userSessions) &gt; 0 </span><span class="cov0" title="0">{
                        userNames = append(userNames, user.Name)
                }</span>
        }
        <span class="cov0" title="0">return userNames</span>
}

func (c ChatService) QuitSession(sessionID string) <span class="cov0" title="0">{
        session, sessionExists := c.sessionRepository.FindByID(sessionID)
        if !sessionExists </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">session.Close &lt;- struct{}{}
        c.userSessionRepository.DeleteBySessionID(sessionID)
        c.sessionRepository.Delete(sessionID)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package application

import "fmt"

type UserFriendlyError interface {
        error
        UserFriendlyError() string
}

type BaseError struct {
        sessionID string
        message   string
        userMsg   string
}

func NewBaseError(sessionID, message, userMsg string) BaseError <span class="cov0" title="0">{
        return BaseError{
                sessionID: sessionID,
                message:   message,
                userMsg:   userMsg,
        }
}</span>

func (e BaseError) Error() string <span class="cov0" title="0">{
        return e.message
}</span>

func (e BaseError) UserFriendlyError() string <span class="cov0" title="0">{
        return e.userMsg
}</span>

type ErrSessionNotLoggedIn struct {
        BaseError
}

func NewErrSessionNotLoggedIn(sessionID string) *ErrSessionNotLoggedIn <span class="cov0" title="0">{
        return &amp;ErrSessionNotLoggedIn{NewBaseError(
                sessionID,
                fmt.Sprintf("session %s not logged in", sessionID),
                "you are not logged in",
        )}
}</span>

type ErrMessagePartnerDoesNotExist struct {
        BaseError
}

func NewErrMessagePartnerDoesNotExist(sessionID string, messagePartnerUserName string) *ErrMessagePartnerDoesNotExist <span class="cov0" title="0">{
        return &amp;ErrMessagePartnerDoesNotExist{NewBaseError(
                sessionID,
                fmt.Sprintf("session %s tried to Message non existant partner %s", sessionID, messagePartnerUserName),
                "your Message partner does not seem to be logged in",
        )}
}</span>

type ErrMessagePartnerNotLoggedIn struct {
        BaseError
}

func NewErrMessagePartnerNotLoggedIn(sessionID string, messagePartnerUserName string) *ErrMessagePartnerNotLoggedIn <span class="cov0" title="0">{
        return &amp;ErrMessagePartnerNotLoggedIn{NewBaseError(
                sessionID,
                fmt.Sprintf("session %s tried to Message non logged in partner %s", sessionID, messagePartnerUserName),
                "your Message partner does not seem to be logged in",
        )}
}</span>

type ErrCouldNotCreateUser struct {
        BaseError
}

func NewErrCouldNotCreateUser(sessionID string) *ErrCouldNotCreateUser <span class="cov0" title="0">{
        return &amp;ErrCouldNotCreateUser{NewBaseError(
                sessionID,
                fmt.Sprintf("could not create user for session id: %s", sessionID),
                "could not create user, password is likely invalid",
        )}
}</span>

type ErrUserNameAlreadyExists struct {
        BaseError
}

func NewErrUserNameAlreadyExists(sessionID string, userName string) *ErrUserNameAlreadyExists <span class="cov0" title="0">{
        return &amp;ErrUserNameAlreadyExists{NewBaseError(
                sessionID,
                fmt.Sprintf("session %s tried to create user %s that already exists", sessionID, userName),
                "a user with that name already exists",
        )}
}</span>

type ErrUserDoesNotExist struct {
        BaseError
}

func NewErrUserDoesNotExist(sessionID string, userName string) *ErrUserDoesNotExist <span class="cov0" title="0">{
        return &amp;ErrUserDoesNotExist{NewBaseError(
                sessionID,
                fmt.Sprintf("session %s tried to access user %s that does not exist", sessionID, userName),
                "a user with that name does not exist",
        )}
}</span>

type ErrPasswordIsInvalid struct {
        BaseError
}

func NewErrPasswordIsInvalid(sessionID string) *ErrPasswordIsInvalid <span class="cov0" title="0">{
        return &amp;ErrPasswordIsInvalid{NewBaseError(
                sessionID,
                fmt.Sprintf("session %s entered invalid password", sessionID),
                "wrong password",
        )}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package handlers

import (
        "fmt"
        "log/slog"
        "strings"

        "tcpchat-server-go/application"
        "tcpchat-server-go/domain"
)

func HandleCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        slog.Info("received command", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
        matchCommandTypeToFunc(command.CommandType)(command, chatService)
}</span>

func matchCommandTypeToFunc(commandType domain.CommandType) func(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        handlers := []func(command domain.Command, chatService *application.ChatService){
                handleUnknownCommand,        // 0
                handleChangeNameCommand,     // 1
                handlePrivateMessageCommand, // 2
                handleCreateAccountCommand,  // 3
                handleLoginCommand,          // 4
                handleChangePasswordCommand, // 5
                handleInfoCommand,           // 6
                handleWhoCommand,            // 7
                handleQuitCommand,           // 8
        }

        // Ensure commandType is valid and within bounds
        if int(commandType) &lt; 0 || int(commandType) &gt;= len(handlers) </span><span class="cov0" title="0">{
                return handleUnknownCommand
        }</span>

        <span class="cov0" title="0">return handlers[commandType]</span>
}

func handleUnknownCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        slog.Info("received unknown command", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
        chatService.SendMessageToSessionFromServer(command.SessionID, "Unknown command")
}</span>

func handleChangeNameCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        if len(command.Arguments) != 1 </span><span class="cov0" title="0">{
                slog.Info("invalid number of arguments", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
                chatService.SendMessageToSessionFromServer(command.SessionID, "Wrong number of arguments, usage: /name &lt;new username&gt;")
                return
        }</span>
        <span class="cov0" title="0">newUserName := command.Arguments[0]
        err := chatService.ChangeUserName(command.SessionID, newUserName)
        if err != nil </span><span class="cov0" title="0">{
                handleErrors(err, chatService, command.SessionID)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("changed name of user", "sessionID", command.SessionID, "newUserName", newUserName)
        chatService.SendMessageToSessionFromServer(command.SessionID, fmt.Sprintf("Changed username to %s", newUserName))</span>
}

func handlePrivateMessageCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        if len(command.Arguments) &lt; 2 </span><span class="cov0" title="0">{
                slog.Info("invalid number of arguments", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
                chatService.SendMessageToSessionFromServer(command.SessionID, "Wrong number of arguments, usage: /msg &lt;username&gt; &lt;message...&gt;")
                return
        }</span>
        <span class="cov0" title="0">messagePartnerUserName := command.Arguments[0]
        message := strings.Join(command.Arguments[1:], " ")
        err := chatService.SendPrivateMessage(command.SessionID, messagePartnerUserName, message)
        if err != nil </span><span class="cov0" title="0">{
                handleErrors(err, chatService, command.SessionID)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("sent private message", "sessionID", command.SessionID, "messagePartnerUserName", messagePartnerUserName)</span>
}

func handleCreateAccountCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        if len(command.Arguments) != 2 </span><span class="cov0" title="0">{
                slog.Info("invalid number of arguments", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
                chatService.SendMessageToSessionFromServer(command.SessionID, "Wrong number of arguments, usage: /acc &lt;username&gt; &lt;password&gt;")
                return
        }</span>
        <span class="cov0" title="0">userName := command.Arguments[0]
        password := command.Arguments[1]
        err := chatService.CreateAccount(command.SessionID, userName, password)
        if err != nil </span><span class="cov0" title="0">{
                handleErrors(err, chatService, command.SessionID)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("created new account", "userName", userName)
        chatService.SendMessageToSessionFromServer(command.SessionID, "Created new account, please login now")</span>
}

func handleLoginCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        if len(command.Arguments) != 2 </span><span class="cov0" title="0">{
                slog.Info("invalid number of arguments", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
                chatService.SendMessageToSessionFromServer(command.SessionID, "Wrong number of arguments, usage: /login &lt;username&gt; &lt;password&gt;")
                return
        }</span>
        <span class="cov0" title="0">userName := command.Arguments[0]
        password := command.Arguments[1]

        err := chatService.Login(command.SessionID, userName, password)
        if err != nil </span><span class="cov0" title="0">{
                handleErrors(err, chatService, command.SessionID)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("logged in session", "sessionID", command.SessionID, "userName", userName)
        chatService.SendMessageToSessionFromServer(command.SessionID, "Logged in")</span>
}

func handleChangePasswordCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        if len(command.Arguments) != 2 </span><span class="cov0" title="0">{
                slog.Info("invalid number of arguments", "sessionID", command.SessionID, "commandType", command.CommandType, "commandArgs", command.Arguments)
                chatService.SendMessageToSessionFromServer(command.SessionID, "Wrong number of arguments, usage: /passwd &lt;old password&gt; &lt;new password&gt;")
                return
        }</span>
        <span class="cov0" title="0">oldPassword := command.Arguments[0]
        newPassword := command.Arguments[1]
        err := chatService.ChangePassword(command.SessionID, oldPassword, newPassword)
        if err != nil </span><span class="cov0" title="0">{
                handleErrors(err, chatService, command.SessionID)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("changed password of user associated with session", "sessionID", command.SessionID)
        chatService.SendMessageToSessionFromServer(command.SessionID, "Changed Password")</span>
}

func handleInfoCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        userName := chatService.GetUserNameForSessionID(command.SessionID)
        slog.Info("served info", "sessionID", command.SessionID)
        chatService.SendMessageToSessionFromServer(command.SessionID, fmt.Sprintf("sessionID: %s\n[plugin] userName:  %s", command.SessionID, userName))
}</span>

func handleWhoCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        for _, userName := range chatService.GetAllLoggedInUserNames() </span><span class="cov0" title="0">{
                chatService.SendMessageToSessionFromServer(command.SessionID, userName)
        }</span>
        <span class="cov0" title="0">slog.Info("served who", "sessionID", command.SessionID)</span>
}

func handleQuitCommand(command domain.Command, chatService *application.ChatService) <span class="cov0" title="0">{
        chatService.QuitSession(command.SessionID)
        slog.Info("quit session", "sessionID", command.SessionID)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package handlers

import (
        "errors"
        "log/slog"

        "tcpchat-server-go/application"
)

func handleErrors(err error, chatService *application.ChatService, sessionID string) <span class="cov8" title="1">{
        var userFriendlyError application.UserFriendlyError
        if errors.As(err, &amp;userFriendlyError) </span><span class="cov0" title="0">{
                slog.Info("recovered from error", "err", err)
                chatService.SendMessageToSessionFromServer(sessionID, userFriendlyError.UserFriendlyError())
        }</span> else<span class="cov8" title="1"> {
                slog.Error("internal server error", "err", err)
                chatService.SendMessageToSessionFromServer(sessionID, "internal server error")
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package handlers

import (
        "context"

        "tcpchat-server-go/application"
        "tcpchat-server-go/domain"
)

// HandleMessages handles all incoming messages.
func HandleMessages(ctx context.Context, sessions &lt;-chan domain.Session, textMessages &lt;-chan domain.TextMessage, commands &lt;-chan domain.Command) <span class="cov0" title="0">{
        sessionRepository := domain.NewInMemorySessionRepository()
        userRepository := domain.NewInMemoryUserRepository()
        userSessionRepository := domain.NewInMemoryUserSessionRepository()
        chatService := application.NewChatService(sessionRepository, userRepository, userSessionRepository)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case newSession := &lt;-sessions:<span class="cov0" title="0">
                        HandleNewSession(newSession, chatService)</span>
                case textMessage := &lt;-textMessages:<span class="cov0" title="0">
                        HandleTextMessage(textMessage, chatService)</span>
                case command := &lt;-commands:<span class="cov0" title="0">
                        HandleCommand(command, chatService)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package handlers

import (
        "log/slog"

        "tcpchat-server-go/application"
        "tcpchat-server-go/domain"
)

func HandleNewSession(newSession domain.Session, chatService *application.ChatService) <span class="cov0" title="0">{
        slog.Info("received new session", "sessionID", newSession.ID)
        chatService.RegisterNewSession(newSession)
        slog.Info("registered new session", "sessionID", newSession.ID)
        chatService.SendMessageToSessionFromServer(newSession.ID, "Welcome to this plugin!")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package handlers

import (
        "log/slog"

        "tcpchat-server-go/application"
        "tcpchat-server-go/domain"
)

func HandleTextMessage(textMessage domain.TextMessage, chatService *application.ChatService) <span class="cov0" title="0">{
        slog.Info("received text message", "sessionID", textMessage.SessionID, "textMessage", textMessage.Message)
        err := chatService.SendTextMessageToEveryone(textMessage.SessionID, textMessage.Message)
        if err != nil </span><span class="cov0" title="0">{
                handleErrors(err, chatService, textMessage.SessionID)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("sent text message from to everyone", "sessionID", textMessage.SessionID, "textMessage", textMessage.Message)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package application

import (
        "context"
        "errors"
        "io"
        "log/slog"
        "strings"

        "tcpchat-server-go/domain"
)

// MessageResult is used to couple a possible error when sending a Message.
type MessageResult struct {
        SessionID string
        Message   string
        Err       error
}

// ConvertMessages converts incoming messages into their respective internal types.
func ConvertMessages(ctx context.Context, incomingMessages &lt;-chan MessageResult, textMessages chan&lt;- domain.TextMessage, commands chan&lt;- domain.Command) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case incomingMessage := &lt;-incomingMessages:<span class="cov0" title="0">
                        message := cleanIncomingMessageString(incomingMessage.Message)
                        slog.Debug("incoming Message", "Message", message)
                        if incomingMessage.Err != nil </span><span class="cov0" title="0">{
                                slog.Warn("incoming Message error", "Err", incomingMessage.Err)
                                if errors.Is(incomingMessage.Err, io.EOF) </span><span class="cov0" title="0">{
                                        commands &lt;- domain.Command{SessionID: incomingMessage.SessionID, CommandType: domain.Quit, Arguments: nil}
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">if strings.HasPrefix(message, "/") </span><span class="cov0" title="0">{
                                command := strings.TrimPrefix(message, "/")
                                commandSplit := strings.Fields(command)
                                commandType := commandSplit[0]
                                commandArgs := commandSplit[1:]
                                commands &lt;- domain.Command{SessionID: incomingMessage.SessionID, CommandType: domain.MatchCommandTypeStringToCommandType(commandType), Arguments: commandArgs}
                        }</span> else<span class="cov0" title="0"> {
                                textMessages &lt;- domain.TextMessage{SessionID: incomingMessage.SessionID, Message: message}
                        }</span>
                }
        }
}

// cleanIncomingMessageString is a helper function to clean strings that were received by the client.
func cleanIncomingMessageString(message string) string <span class="cov0" title="0">{
        return strings.TrimSpace(strings.TrimSuffix(strings.TrimSuffix(message, "\n"), "\r"))
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package domain

type CommandType int

const (
        Unknown CommandType = iota
        ChangeName
        PrivateMessage
        CreateAccount
        Login
        ChangePassword
        Info
        Who
        Quit
)

// String implements the string variants of CommandType.
func (c CommandType) String() string <span class="cov0" title="0">{
        return [...]string{"unknown", "name", "msg", "acc", "login", "passwd", "info", "who", "quit"}[c]
}</span>

// MatchCommandTypeStringToCommandType is used to mach a received command as a string to the CommandType used to communicate the command.
func MatchCommandTypeStringToCommandType(s string) CommandType <span class="cov0" title="0">{
        for currentCommandType := Unknown; currentCommandType &lt;= Quit; currentCommandType++ </span><span class="cov0" title="0">{
                if currentCommandType.String() == s </span><span class="cov0" title="0">{
                        return currentCommandType
                }</span>
        }
        <span class="cov0" title="0">return Unknown</span>
}

// Command represents a command a user wants to be executed.
type Command struct {
        SessionID   string
        CommandType CommandType
        Arguments   []string
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package domain

import "github.com/google/uuid"

// Session represents a newly created session.
type Session struct {
        ID                string
        MessagesToSession chan&lt;- string
        Close             chan&lt;- interface{}
}

func NewSession(messagesToSession chan&lt;- string, close chan&lt;- interface{}) *Session <span class="cov0" title="0">{
        return &amp;Session{uuid.New().String(), messagesToSession, close}
}</span>

type SessionRepository interface {
        Add(Session) bool
        FindByID(string) (session Session, sessionExists bool)
        FindAllExceptBySessionID(string) []Session
        Delete(string) (session Session, sessionExists bool)
}

type InMemorySessionRepository struct {
        sessions map[string]Session
}

func NewInMemorySessionRepository() *InMemorySessionRepository <span class="cov0" title="0">{
        return &amp;InMemorySessionRepository{sessions: make(map[string]Session)}
}</span>

func (i *InMemorySessionRepository) Add(session Session) bool <span class="cov0" title="0">{
        if _, sessionExists := i.sessions[session.ID]; sessionExists </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">i.sessions[session.ID] = session
        return true</span>
}

func (i *InMemorySessionRepository) Delete(sessionID string) (session Session, ok bool) <span class="cov0" title="0">{
        if session, ok = i.sessions[sessionID]; !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(i.sessions, sessionID)
        return</span>
}

func (i *InMemorySessionRepository) FindByID(id string) (session Session, ok bool) <span class="cov0" title="0">{
        session, ok = i.sessions[id]
        return
}</span>

func (i *InMemorySessionRepository) FindAllExceptBySessionID(id string) []Session <span class="cov0" title="0">{
        sessions := make([]Session, 0)
        for _, session := range i.sessions </span><span class="cov0" title="0">{
                if session.ID != id </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span>
        }
        <span class="cov0" title="0">return sessions</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package domain

import (
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type User struct {
        ID             string
        Name           string
        hashedPassword string
}

func NewUser(name, password string) (*User, error) <span class="cov0" title="0">{
        user := User{uuid.New().String(), name, ""}
        err := user.SetPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (u *User) SetPassword(password string) error <span class="cov0" title="0">{
        // TODO add password validation
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u.hashedPassword = string(hashedPassword)
        return nil</span>
}

func (u *User) PasswordIsValid(password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(u.hashedPassword), []byte(password))
        return err == nil
}</span>

type UserRepository interface {
        Add(*User) bool
        GetAll() []*User
        FindByID(string) (user *User, userExists bool)
        FindByName(string) (user *User, userExists bool)
        Delete(string) (user *User, userExists bool)
}

type InMemoryUserRepository struct {
        users map[string]*User
}

func NewInMemoryUserRepository() *InMemoryUserRepository <span class="cov0" title="0">{
        return &amp;InMemoryUserRepository{users: make(map[string]*User)}
}</span>

func (i *InMemoryUserRepository) Add(user *User) bool <span class="cov0" title="0">{
        if _, userExists := i.users[user.Name]; userExists </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if _, userExists := i.FindByID(user.ID); userExists </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">i.users[user.Name] = user
        return true</span>
}

func (i *InMemoryUserRepository) GetAll() []*User <span class="cov0" title="0">{
        users := make([]*User, 0)
        for _, user := range i.users </span><span class="cov0" title="0">{
                users = append(users, user)
        }</span>
        <span class="cov0" title="0">return users</span>
}

func (i *InMemoryUserRepository) FindByID(userID string) (*User, bool) <span class="cov0" title="0">{
        for _, user := range i.users </span><span class="cov0" title="0">{
                if user.ID == userID </span><span class="cov0" title="0">{
                        return user, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

func (i *InMemoryUserRepository) FindByName(name string) (user *User, userExists bool) <span class="cov0" title="0">{
        user, userExists = i.users[name]
        return
}</span>

func (i *InMemoryUserRepository) Delete(name string) (user *User, userExists bool) <span class="cov0" title="0">{
        if user, userExists = i.users[name]; !userExists </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(i.users, name)
        return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package domain

type UserSession struct {
        UserID    string
        SessionID string
}

func NewUserSession(userID string, sessionID string) *UserSession <span class="cov0" title="0">{
        return &amp;UserSession{userID, sessionID}
}</span>

type UserSessionRepository interface {
        Add(*UserSession)
        GetAll() []*UserSession
        FindBySessionID(string) (*UserSession, bool)
        FindByUserID(string) []*UserSession
        DeleteBySessionID(string) (*UserSession, bool)
        DeleteByUserID(string) []*UserSession
}

type InMemoryUserSessionRepository struct {
        userSessions map[string]*UserSession
}

func NewInMemoryUserSessionRepository() *InMemoryUserSessionRepository <span class="cov0" title="0">{
        return &amp;InMemoryUserSessionRepository{userSessions: make(map[string]*UserSession)}
}</span>

func (i *InMemoryUserSessionRepository) Add(session *UserSession) <span class="cov0" title="0">{
        i.userSessions[session.SessionID] = session
}</span>

func (i *InMemoryUserSessionRepository) GetAll() []*UserSession <span class="cov0" title="0">{
        allUserSessions := make([]*UserSession, 0, len(i.userSessions))
        for _, userSession := range i.userSessions </span><span class="cov0" title="0">{
                allUserSessions = append(allUserSessions, userSession)
        }</span>
        <span class="cov0" title="0">return allUserSessions</span>
}

func (i *InMemoryUserSessionRepository) FindBySessionID(sessionID string) (userSession *UserSession, ok bool) <span class="cov0" title="0">{
        userSession, ok = i.userSessions[sessionID]
        return
}</span>

func (i *InMemoryUserSessionRepository) FindByUserID(userID string) []*UserSession <span class="cov0" title="0">{
        userSessions := make([]*UserSession, 0)
        for _, userSession := range i.userSessions </span><span class="cov0" title="0">{
                if userSession.UserID == userID </span><span class="cov0" title="0">{
                        userSessions = append(userSessions, userSession)
                }</span>
        }
        <span class="cov0" title="0">return userSessions</span>
}

func (i *InMemoryUserSessionRepository) DeleteBySessionID(sessionID string) (userSession *UserSession, ok bool) <span class="cov0" title="0">{
        if userSession, ok = i.userSessions[sessionID]; !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(i.userSessions, sessionID)
        return</span>
}

func (i *InMemoryUserSessionRepository) DeleteByUserID(userID string) []*UserSession <span class="cov0" title="0">{
        userSessions := i.FindByUserID(userID)
        for _, userSession := range i.userSessions </span><span class="cov0" title="0">{
                _, _ = i.DeleteBySessionID(userSession.SessionID)
        }</span>
        <span class="cov0" title="0">return userSessions</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package main

import (
        "context"
        "log/slog"
        "os"

        "tcpchat-server-go/plugin"
)

func main() <span class="cov0" title="0">{
        setupLogging()
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        tcpChatServer, err := plugin.NewTCPChatServer("localhost", 8080)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to initialize tcp chat plugin", "err", err)
                return
        }</span>
        <span class="cov0" title="0">err = tcpChatServer.Start(ctx)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("error: failed to start tcp chat plugin", "err", err)
                return
        }</span>
}

func setupLogging() <span class="cov0" title="0">{
        logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
        slog.SetDefault(logger)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package plugin

import (
        "context"
        "log/slog"
        "net"
        "sync"

        "tcpchat-server-go/application"
        "tcpchat-server-go/domain"
)

// ConnectionResult is used to couple a possible error when accepting a connection with its result.
type ConnectionResult struct {
        connection net.Conn
        err        error
}

// handleConnections is used to couple a possible error when accepting a connection with its result.
func handleConnections(ctx context.Context, listener net.Listener, activeConnections *sync.WaitGroup, messagesRead chan&lt;- application.MessageResult, sessions chan&lt;- domain.Session) <span class="cov0" title="0">{
        connections := generateConnections(ctx, listener)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case connectionResult := &lt;-connections:<span class="cov0" title="0">
                        if connectionResult.err != nil </span><span class="cov0" title="0">{
                                slog.Error("error accepting connection", "err", connectionResult.err)
                                continue</span>
                        }
                        <span class="cov0" title="0">go handleConnection(ctx, connectionResult.connection, activeConnections, sessions, messagesRead)</span>
                }
        }
}

// generateConnections is used to accept incoming connections and send them on to a channel.
func generateConnections(ctx context.Context, listener net.Listener) &lt;-chan ConnectionResult <span class="cov0" title="0">{
        connections := make(chan ConnectionResult, 5) // Buffer of 5 to allow minor burst handling

        go func() </span><span class="cov0" title="0">{
                defer close(connections)
                for </span><span class="cov0" title="0">{
                        conn, err := listener.Accept()
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case connections &lt;- ConnectionResult{connection: conn, err: err}:<span class="cov0" title="0"></span>
                        }
                }
        }()

        <span class="cov0" title="0">return connections</span>
}

// handleConnection handles a single connection along with reading to and writing from the connection.
func handleConnection(ctx context.Context, connection net.Conn, activeConnections *sync.WaitGroup, sessions chan&lt;- domain.Session, readMessages chan&lt;- application.MessageResult) <span class="cov0" title="0">{
        messagesToSession := make(chan string)
        closeSession := make(chan interface{})
        session := domain.NewSession(messagesToSession, closeSession)
        slog.Info("new connection established", "sessionID", session.ID, "remoteAddr", connection.RemoteAddr())
        defer func() </span><span class="cov0" title="0">{
                slog.Info("closing session", "sessionID", session.ID, "remoteAddr", connection.RemoteAddr())
                connection.Close()
                activeConnections.Done()
        }</span>()
        <span class="cov0" title="0">activeConnections.Add(1)

        sessions &lt;- *session

        localCtx, closeLocalCtx := context.WithCancel(ctx)
        defer closeLocalCtx()

        go handleRead(localCtx, connection, readMessages, session.ID)
        go handleWrite(localCtx, connection, messagesToSession)

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        case &lt;-closeSession:<span class="cov0" title="0"></span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package plugin

import (
        "bufio"
        "bytes"
        "context"
        "io"
        "log/slog"

        "tcpchat-server-go/application"
)

// handleRead is used to read from a reader and return the result on a channel.
func handleRead(ctx context.Context, reader io.Reader, messages chan&lt;- application.MessageResult, sessionID string) <span class="cov0" title="0">{
        bufioReader := bufio.NewReader(reader)
        for </span><span class="cov0" title="0">{
                line, err := bufioReader.ReadString('\n')
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case messages &lt;- application.MessageResult{SessionID: sessionID, Message: line, Err: err}:<span class="cov0" title="0"></span>
                }
        }
}

// handleWrite is used to write from a channel to a writer.
func handleWrite(ctx context.Context, writer io.Writer, messages &lt;-chan string) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case message := &lt;-messages:<span class="cov0" title="0">
                        _, err := io.Copy(writer, bytes.NewBuffer([]byte(message)))
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Warn("write error", "err", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2024 Benedict Weis. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see &lt;https://opensource.org/licenses/MIT&gt;.

package plugin

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "sync"

        "tcpchat-server-go/application"
        "tcpchat-server-go/application/handlers"
        "tcpchat-server-go/domain"
)

type TCPChatServer struct {
        address net.TCPAddr
}

// NewTCPChatServer creates a new instance of TCPChatServer with an address and a port.
func NewTCPChatServer(address string, port int) (*TCPChatServer, error) <span class="cov0" title="0">{
        tcpAddress, err := net.ResolveTCPAddr("tcp", fmt.Sprintf("%s:%d", address, port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TCPChatServer{address: *tcpAddress}, nil</span>
}

// Start starts the TCPChatServer instance and returns when ctx is Done.
func (t *TCPChatServer) Start(ctx context.Context) error <span class="cov0" title="0">{
        slog.Info("starting tcp chat plugin", "address", t.address.String())
        listener, err := net.ListenTCP("tcp", &amp;t.address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer listener.Close()
        var activeConnections sync.WaitGroup
        t.createNecessaryGoroutines(ctx, listener, &amp;activeConnections)
        slog.Info("tcp chat is up", "address", t.address.String())
        &lt;-ctx.Done()
        slog.Info("context is done, waiting for active connections to be closed", "address", t.address.String())
        activeConnections.Wait()
        slog.Info("active connections closed, stopping the plugin", "address", t.address.String())
        return nil</span>
}

func (t *TCPChatServer) createNecessaryGoroutines(ctx context.Context, listener net.Listener, activeConnections *sync.WaitGroup) <span class="cov0" title="0">{
        messagesRead := make(chan application.MessageResult, 5) // Buffer to allow for bursts when sending messages
        sessions := make(chan domain.Session)
        textMessages := make(chan domain.TextMessage)
        commands := make(chan domain.Command)
        go application.ConvertMessages(ctx, messagesRead, textMessages, commands)
        go handlers.HandleMessages(ctx, sessions, textMessages, commands)
        go handleConnections(ctx, listener, activeConnections, messagesRead, sessions)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
